/*
디스럭처링 : 배열구조분해, 객체구조분해 등을 통해서
            멤버들을 편하게 변수로 받을 수 있게 하는 문법
+ 스프레드 연산
=> 편의성 때문에 등장한 문법
*/

// 객체 생성방법 중 1.객체 리터럴
let station = {
    s1 : '모라역',
    s2 : '사상역',
    s3 : '서면역',
    s4 : ['센텀역', '해운대역', '부산역']
}
console.log(station) // { s1: '모라역', s2: '사상역', s3: '서면역', s4: [ '센텀역', '해운대역', '부산역' ] }
console.log(station.s2)
console.log(station.s4[2]) // 부산역

// 사상역, 부산역을 출력하시오
console.log(station.s2, station.s4[2])
console.log(`${station.s2} ${station.s4[2]}`)

// s1, s5처럼 (객체명 입력 없이) 간단하게 접근은 안 되는가? -> 표준에서 지원
// 객체구조분해, 배열구조분해가 추가되었다 -> 간결하게 표현하자
// 객체구조분해 -> 멤버 변수와 동일한 변수명을 왼쪽에 배치
// 오른쪽에 객체를 쓰고, 왼쪽에 필요한 변수명만 쓰면 된다
let {s2, s3, s5} = station // s2, s3는 멤버로 존재, s5는 멤버로 존재 X
console.log(s2, s3, s5) // 사상역 서면역 undefined

// s2값을 변경하면 station 내 s2가 영향을 받는가?
s2 = '컴퓨터'
console.log(s2, station.s2) // 컴퓨터 사상역 -> 영향 X

// 배열구조분해 -> (한계점) 개수를 알아야 하는 등 개선점이 필요하다
// 배열 : 순서, 인덱스가 존재한다, 값 하나하나에 대응하는 이름이 따로 없다
// 이름은 마음대로, 단 순서가 중요
let [a1] = station.s4
console.log(a1) // 순서대로, 첫번째 값 

// 세번째 값(부산역)을 출력하려면
let [ , , a3] = station.s4
console.log(a3)